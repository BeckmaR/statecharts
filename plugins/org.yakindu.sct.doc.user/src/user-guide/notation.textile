p.

h1(#sc_notation). Notation of Statecharts

Statecharts are a graphical modeling language. Therefore, like all languages, statecharts are composed of certain objects and symbols. This chapter describes the different notational symbols that are available and valid compositions thereof. 

The interaction of statechart objects and their semantical meanings are described in "Semantics of Statecharts":../user-guide/semantics.html#sc_semantics.

h2(#sc_notation_overview). Overview

Statecharts are composed of two sets of notational objects:
* "Graphical elements":#sc_notation_graphical
* "Nongraphical elements":#sc_notation_nongraphical

While graphical elements describe the structure of the statechart, certain nongraphical elements like names, data and behavior descriptions are needed as well. These elements are organized in a hierarchical manner. Like in a regular language, where certain words can follow each other and others can not, certain elements of the statechart language can _contain_ certain other ones.

h3(#sc_notation_graphical). Graphical Elements

This section describes the graphical elements of the statechart notation. 

* "Regions":#sc_notation_regions
* "States":#sc_notation_states
** "Regular States":#sc_notation_regular_states
*** Composite States
*** Orthogonal States
*** Final States
** Nonregular states
*** Entry States
*** History States
*** Exit States
*** Choices
*** Synchronizations
* "Transitions":#sc_notation_transitions

h4(#sc_notation_regions). Regions

The basic building blocks of YAKINDU Statecharts are regions. Regions contain "States":#sc_notation_states and "Transitions":#sc_notation_transitions. Regions can be contained in the statechart itself, and all statecharts are composed of one or more regions. Alternatively, regions can be contained in states to model deeper hierarchies. States can contain zero or more regions. Regions in States are called Subregions, whereas those on the root level are called Top-Level Regions.

When two or more regions are contained in the same element (a State or the statechart itself), these regions are said to be _parallel_ or _orthogonal_. Parallel regions are ordered by a _Region Priority_. In the image above, the Regions _r1_ and _r2_ are parallel, while _r2_1_ and _r2_2_ are *not* - they are not contained in the same element.

p(#sc_notation_fig_overview_regions). 
!images/notation/overview_region.png(Overview over regions)!

p=. Overview over Region concepts

h4(#sc_notation_states). States

*States* are the central elements of a state machine. There are several kinds of states with different characteristics and constraints. All states have to be contained in a "region":#sc_notation_regions and must have a name that is unique within this region (exception: Synchronizations and Choices).

States are connected by "Transitions":#sc_notation_transitions. Transitions are directed, therefore states have _incoming_ and _outgoing_ transitions. All states must have at least one incoming transition and zero or more outgoing transitions (with the notable exception of the _Entry State_ and the _History State_, which have exactly one outgoing and zero incoming transitions).

h4(#sc_notation_regular_states). Regular States

Regular States are the most "basic" and versatile kind of state in statecharts. They are displayed as rounded rectangles with two textboxes, as shown in the following image:

p(#sc_notation_regular_states_img). 
!images/notation/basic_state.png(Regular State)!

p=. A Regular State with a name and behavior.

The upper text denotes the _name_ of the state, which is obligatory and must be unique within the "Region":#sc_notation_regions the state is contained in. The lower text is optional and is the behavior specification of the state. The behavior specification consists of a sequence of "_local reactions_":#sclang_reactions. The behavior specifies which "actions":#sclang_reactions are executed on which conditions. Such actions can be triggered by entering the state, leaving the state, occurrence of events, conditions becoming true, or time passing. 

Furthermore, Regular States (and only those) can contain Regions, see the next section "Composite and Orthogonal States":#sc_notation_composite_orthogonal_state.

==<div class="example">==

The statechart below has three states, *Countdown*, *Rocket launched* and *Countdown canceled*. The state *Countdown* has three local reactions:

p(#sclang_fig_state_example). 
!images/docu_state_010_example_01.png(State example)!

p=. State example: A simple state machine to launch a rocket.

==</div>==

h5(#sc_notation_composite_orthogonal_state). Composite and Orthogonal States

"Regular States":#sc_notation_regular_states can contain other "Regions":#sc_notation_regions. A State that contains one subregion is called a _Composite State_. A State with two or more subregions is called an _Orthogonal State_.

p(#sc_notation_composite_orthogonal_states_img). 
!images/notation/overview_composite_states.png(Composite and Orthogonal State)!

p=. A Composite State containing another Orthogonal State.


h4(#sc_notation_other_states). Other state types

As mentioned before, there are quite a few other kinds of state available. While they do have certain notational differences and varying notational constraints, most of their differences are a of semantical nature. Therefore, this chapter shall only give an overview over the notational constraints of all state kinds:

|/2_. State Kind |/2_. Image |\2_. # Transitions |/2_. # in Region |/2_. Notes|
|_. → _in_ |_. _out_ → |
| _Regular State_ | !images/notation/small_state.png(Regular State)! | 1 : n | 0 : n | 0 : n | Basic building block of statecharts, can contain regions. |
| _Entry State_ | !images/notation/small_entry.png(Entry State)! | 0 | 1 |/3 1 : n |/3 Interchangeable with each other. |
| _History State_ | !images/notation/small_history.png(History State)! | 0 | 1 |
| _Deep History State_ | !images/notation/small_deep_history.png(Deep History State)! | 0 | 1 |
| _Final State_ | !images/notation/small_final_state.png(Final State)! | 1 : n | 0 | 0 : 1 | |
| _Exit State_ | !images/notation/small_exit_state.png(Exit State)! | 1 : n | 0 | 0 : n | Exit States are not allowed on Top-Level Regions.|
| _Choice_ | !images/notation/small_choice_state.png(Choice State)! | 1 : n | 2 : n | 0 : n | |
| _Synchronization_ | !images/notation/small_sync.png(Synchronization)! | 1 : n | 1 : n | 0 : n | |

h4(#sc_notation_transitions). Transitions

Transitions are directed connections between "States":#sc_notation_states. They are displayed as arrows. Transitions always have a _source state_ and a _target state_, signified by the direction of the arrow. These can be the same state or two different states. The connected states can be contained in the same or in different "regions":#sc_notation_regions, as long as these regions are not _orthogonal_. Especially, Transitions are allowed to go up and down in the hierarchy of subregions.

The transitions that have a certain state as _target state_ are those state's _incoming_ transitions, while those that share a _source state_ are those state's _outgoing_ transitions. When more than one outgoing transition is present, the transitions are ordered by their transition priority.

Transitions have a text box that contains a description of the transition's behavior. Similar to States, the behavior is specified by a _"local reaction":#sclang_reactions_.

All the concepts in one image:

p(#sclang_fig_transition_example). 
!images/notation/overview_transition.png(Transitions)!

p=. Transitions explained



h3(#sc_notation_nongraphical). Nongraphical Elements

