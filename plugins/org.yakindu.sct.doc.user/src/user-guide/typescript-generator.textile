
h1(#codegen_ts_code_generator). TypeScript code generator

h2(#codegen_ts_code_generator_features). TypeScript code generator features

The *GeneratorOptions* feature allows to change the behavior of the TS generator:

* _useAngular_ (Boolean, required): This parameter is used to specify that the statechart should be generated as Angular service.
* _useEventQueue_ (Boolean, required): This parameter is used to specify that the statechart should be generated with an event driven behavior.  

==<div class="example">==

Example:

bc. feature GeneratorFeatures {
    useAngular = true
    useEventQueue = true
}

==</div>==

The *OutletFeature*  specifies target project and target folder for the generated artifacts. It is a required feature and has the following parameters:

* _targetProject_ (String, required): The project to store the generated artifacts to. 
* _targetFolder_ (String, required): The folder to store the generated artifacts to. If a library folder is given, only the dynamic (i.e. model-dependent artifacts) are generated into the target folder, if not all generated artifacts will be generated into it. All artifacts in this folder will be overwritten during re-generation. 
* _libraryTargetFolder_(String, optional): The folder to store the static (i.e. model-independent artifacts) to. In case this is not specified, all artifacts will be generated into the target folder. All artifacts in this folder will be preserved during re-generation. 
* _apiTargetFolder_ (String, optional): The folder to store API code, e.g. interfaces. In case this is not specified, all artifacts will be generated into the target folder. 

==<div class="example">==

Example:

bc. feature Outlet {
    targetProject = "ycar_app"
    targetFolder  = "src/app/gen/statemachine"
    libraryTargetFolder = "src/app/gen/stateutils"
}

==</div>==
==<!-- End sgen_feature_generatoroptions -->==


h2(#codegen_ts_specification_of_cpp_code). Specification of TypeScript code

In order to describe the API specifications of the code generated by the YAKINDU TypeScript generator, the explanations below are using the _YCar App_ sample state machine, see "figure &quot;The _YCar-App_ sample statechart model&quot;":#docu_ts_ycar_menuservice_statechart. It models view changes if a user interacts with the menu. 

p(#docu_ts_ycar_menuservice_statechart). 
!(full)images/docu_ts_ycar_menuservice_statechart.png(The _YCar App - Menu Service_ sample statechart model)!

p=. The _YCar App Menu Service_ sample statechart model


h3(#codegen_cpp_generated_code_files). Generated code files

You will find the generated code in the _src/app/gen/_ folder of the ycar app example. If the library target folder is set, you will find some util modules for the generated state machine like _statemachine.interface.ts_ or _eventQueue.ts_ in the specified library target folder.



The _statemachine.interface.ts_ module defines the fundamental state machine interface methods. It is needed by each particular state machine and is independend from concrete ones.

The _eventQueue.ts_ module defines the EventQueue class which is needed for the event driven behavior. 


h3(#codegen_ts_statemachine_class). Statemachine class

The state machine source code is generated as a TypeScript class with the same name as the statechart. For example, if the statechart is named _DefaultSM_ the TypeScript class will also be called _DefaultSM_, and it will be generated in the source code file _defaultSM.statemachine.ts_.

If the state machine is generated as Angular Service, the _defaultSM.statemachine.ts_ module imports angular dependencies and decorate the class with an _@Injectable_ decorator 

bc.. 

/**State machine as Angular service **/

import {Injectable} from '@angular/core';
import {EventQueue, Event} from '../stateutils/eventQueue';
import {IStatemachine} from '../stateutils/statemachine.interface';
import {Subject, Subscription} from 'rxjs';

@Injectable()
export class DefaultSM implements IStatemachine  {
	...
}



h3(#codegen_ts_statemachineinterface). Statemachine Interface

Each generated TypeScript state machine implements the interface _IStateMachine_ from the _statemachine.interface.ts_ module:

bc.. 

/**
 * Basic interface for state machines. TEMPLATE BASED
 */
export interface IStatemachine {

	/**
	 * Initializes the state machine. Used to initialize internal variables etc.
	 */
	 init():void;

	/**
	 * Enters the state machine. Sets the state machine into a defined state.
	 */
	enter():void;

	/**
	 * Exits the state machine. Leaves the state machine with a defined state.
	 */
	 exit():void;

	/**
	 * Checks whether the state machine is active. 
	 * A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
	 */
	  isActive():boolean;

	/**
	 * Checks whether all active states are final. 
	 * If there are no active states then the state machine is considered being incative. In this case this method returns <code>false</code>.
	 */
	  isFinal():boolean;

	/**
	 * Start a run-to-completion cycle.
	 */
	  runCycle():void;
}



h4(#codegen_ts_fundamental_statechart_methods). Fundamental statechart methods

The generated code contains fundamental methods to initialize, enter, and exit a state machine, as well as a function to execute a run-to-completion step.

The _IStateMachine_ interface specifies the four functions _init()_, _enter()_, _exit()_ and _runCycle()_.

<ul><li><p>The _init()_ function is used to initialize the internal objects of the state machine right after its instantiation. Variables are initialized to their respective default values. If the statechart defines any initialized variables, these initializations are also done in the _init()_ function.</p></li><li><p>The _enter()_ function must be called to enter the state machine. It brings the state machine to a well-defined state.</p></li><li><p>The _exit()_ function is used to leave a state machine statefully. If for example a history state is used in one of the top regions, the last active state is stored and the state machine is left via _exit()_. Re-entering it via _enter()_ continues to work with the saved state.</p></li><li><p>The _runCycle()_ function is used to trigger a run-to-completion step in which the state machine evaluates arising events and computes possible state changes. Somewhat simplified, a run-to-completion cycle consists of the following steps:</p><ol style="list-style-type:  decimal;"><li><p>Clear the list of outgoing events.</p></li><li><p>Check whether any events have occurred which are leading to a state change.</p></li><li><p>If a state change has to be done:</p><ol style="list-style-type:  decimal;"><li><p>Make the present state inactive.</p></li><li><p>Execute exit actions of the present state.</p></li><li><p>Save history state, if necessary.</p></li><li><p>Execute transition actions, if any.</p></li><li><p>Execute entry actions of the new state.</p></li><li><p>Make the new state active.</p></li></ol></li><li><p>Clear the list of incoming events.</p></li></ol></li></ul>



h3(#codegen_ts_accessing_interfaces_variables_and_events). Accessing interfaces, variables and events

The client code can read and write state machine variables and raise state machine events. In a YAKINDU statechart, variables and events are contained in so-called _interfaces_. There can be at most one default, unnamed interface plus zero or more named interfaces. In the generated TypeScript code, these interfaces can be found as classes of the main state machine module. 

Let's have a look at the following sample statechart interface declaration of a statechart named _DefaultSM_:

bc. interface Sample:
    var a:boolean
    in event evA:boolean
    out event evB:integer

The generated interface code is shown below in the  class _SCISample_ which is part of the _defaultSM.statemachine.ts_ module. Since the statechart's name is _DefaultSM_ the state machine class' name is also _DefaultSM_ and can also be found in the _defaultSM.statemachine.ts_ module file:

bc.. 

import {EventQueue, Event} from '../stateutils/eventQueue';
import {IStatemachine} from '../stateutils/statemachine.interface';
import {Subject, Subscription} from 'rxjs';

export class DefaultSM implements IStatemachine  {
	
	// state machine members
	protected initialized:boolean = false;
	protected stateVector:State[] = new Array<State>(1);
	protected  nextStateIndex:number;
	
	// interface scope
	public readonly Sample:SCISample = new SCISample();
	
	//EventQueue
	private eventQueue:EventQueue = new EventQueue();
	
	public init():void {
		for (let i = 0; i < 1; i++) {
			this.stateVector[i] = State.NullState;
		}
	
		this.clearEvents();
		this.clearOutEvents();
		
		this.eventQueue.onProcess.subscribe((id)=> {
			this.runCycle();
		});	
	
		this.Sample.a=false;
		this.initialized = true;
		}
	
	enter():void {
		 if (!this.initialized) {
			throw 'statemachine is not initialized!';
		 }
		this.enterSequence_main_region_default();
	}
	
	exit():void {
		this.exitSequence_main_region();
	}
	
	runCycle():void {
		this.clearOutEvents();
		
		for (this.nextStateIndex = 0; this.nextStateIndex < this.stateVector.length; this.nextStateIndex++) {
			switch (this.stateVector[this.nextStateIndex]) {
			case State.main_region_StateA:
				this.react_main_region_StateA();
				break;
			default:
				// NullState
				break;
			}
		}
		this.clearEvents();
	}
	
	/**
	 * @see IStatemachine#isActive()
	 */
	public isActive():boolean {
	 	return this.stateVector[0] !== State.NullState;
	}
	
	/** 
	* Always returns 'false' since this state machine can never become final.
	*
	 * @see IStatemachine#isFinal() 
	 */
	public isFinal():boolean {
		return false;
	}
	
	/**
	* This method resets the incoming events (time events included).
	*/
	protected  clearEvents():void {
		this.Sample.clearEvents();
	}
	
	/**
	* This method resets the outgoing events.
	*/
	protected clearOutEvents():void {
		this.Sample.clearOutEvents();
	}
	
	/**
	* Returns true if the given state is currently active otherwise false.
	*/
	public  isStateActive(state:State):boolean {
		switch (state) {
			case State.main_region_StateA: 
				return this.stateVector[0] === State.main_region_StateA;
			default: return false;
		}
	}
	
	/* 'default' enter sequence for state StateA */
	private  enterSequence_main_region_StateA_default():void {
		this.nextStateIndex = 0;
		this.stateVector[0] = State.main_region_StateA;
	}
	/* 'default' enter sequence for region main region */
	private  enterSequence_main_region_default():void {
		this.react_main_region__entry_Default(); 
	}
	/* Default exit sequence for state StateA */
	private  exitSequence_main_region_StateA():void {
		this.nextStateIndex = 0;
		this.stateVector[0] = State.NullState;
	}
	/* Default exit sequence for region main region */
	private  exitSequence_main_region():void {
		switch(this.stateVector[0]) {
			case State.main_region_StateA : 
				this.exitSequence_main_region_StateA();
				break;
			
			default: 
				break;
		}
	}
	/* The reactions of state StateA. */
	private  react_main_region_StateA():void {
	}
	/* Default react sequence for initial entry  */
	private  react_main_region__entry_Default():void {
		this.enterSequence_main_region_StateA_default(); 
	}
	
	
}

export class SCISample {
	public evA$: Subject<any> = new Subject<any>();
	
	evAValue:boolean;
	
	public raiseEvA(value:any):void {
		this.evA$.next(value);
	}
	
	public subscribeEvA(ev:any): Subscription {
		return ev.subscribe((value) => {
			this.raiseEvA(value);
		})
	}
			
	private getEvAValue():boolean  {
		return this.evAValue;
	}
	
	public evB$: Subject<any> = new Subject<any>();
	
	evBValue:number;
	
	raiseEvB(value:number):void {
		this.evB$.next(value);
	}
	
	getEvBValue():number {
		if (this.evBValue === undefined)
			throw "Illegal event value access. Event evB is not raised";
		return this.evBValue;
	}

	public _a:boolean;
	
	get a():boolean {
		return this._a;
	} 
	set a(value:boolean) {
		this._a = value;
	}

	clearEvents():void {}

	clearOutEvents():void {}
 }
 
export interface IOperationCallback {}

export enum State {
	main_region_StateA,
	NullState
}


p. A statechart interface is generated as class within the state machine module (defaultSM.statemachine.ts). The class' name is derived from the statechart interface's name by prepending the string @SCI@.

A special case is the unnamed statechart interface: It is generated as the TypeScript class _SCInterface_.

An incoming event _evA:boolean_ is generated as the raise function _raiseEvA(boolean value)_. Since the event is of type _boolean_ the function has a _boolean_ parameter. In addition to these a subscription method _subscribeEvA(ev:boolean): Subscription_ is generated which represents a disposable resource, such as the execution of an Observable.

For an outgoing event _evB:integer_ the function _getEvBValue(): number_ is generated. The former can be used to determine whether the event has already been raised by the state machine or not. The latter serves to query the value of the event. In addition to this, a Observable property _evB$ of type _Subject_ is generated to subscribe and react on value changes. 

For variables, the code generator creates class properties with getter and setter, here _get a():boolean_ and _void set a(sc_boolean value)_.

The code generator also creates appropriately named _readonly_ instance in the state machine which can be used for acquiring this interface, here: _public readonly Sample: SCISample = new SCISample()_.



h3(#codegen_cpp_operation_callbacks). Operation callbacks

YAKINDU Statechart Tools support operations that are executed by a state machine as actions, but are implemented by client-side code. The figure below shows a sample statechart using an operation:

!images/docu_operationExample.png(Specifying an operation callback in the model)!

p=. Specifying an operation callback in the model

Let's have a look at the additionally generated code for operation support in the _defaultSM.statemachine.ts_ module:

bc.. 
export interface IOperationCallback {
	myOperation?(p1: number, p2: boolean);
}

p. An additional interface _IOperationCallback_ with the optional method _myOperation(p1: number, p2: boolean)_ has been generated. This interface has to be implemented, and an instance of the implementing class has to be provided to the state machine via the _setSampleOperationCallback(operationCallback: IOperationCallback)_ function, so that the state machine can use it.

bc.. 
import {IOperationCallback, DefaultSM} from "./defaultSM.statemachine";

export class Main {

    defaultSM: DefaultSM ;

    constructor() {
        this.defaultSM = new DefaultSM();
    }

    sampleOperatioNCallback: IOperationCallback = {
        myOperation: (p1: number, p2: boolean) => {
            console.log("myOperation")
        }
    };

    init(): void {
        this.defaultSM.setSampleOperationCallback(this.sampleOperationCallback);
        this.defaultSM.init();
        this.defaultSM.enter();
        this.defaultSM.runCycle();
    }
}



