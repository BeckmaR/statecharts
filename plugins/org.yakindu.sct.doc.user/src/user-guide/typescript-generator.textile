
h1(#codegen_ts_code_generator). TypeScript code generator

h2(#codegen_ts_code_generator_features). TypeScript code generator features

==<!-- Start sgen_feature_generatoroptions -->==

The *GeneralFeatures* feature allows to change the behavior of the TypeScript generator:


* _useAngular_ (Boolean, required): This parameter specifies whether the statechart is generated as an Angular service or not.
* _useEventQueue_ (Boolean, required): This parameter specifies whether the statechart is generated with an event-driven behavior.

==<div class="example">==

Example:

bc. feature GeneratorFeatures {
    useAngular = true
    useEventQueue = true
}

==</div>==

==<!-- End sgen_feature_generatoroptions -->==


h2(#codegen_ts_specification_of_typescript_code). Specification of TypeScript code

In order to describe the API specifications of the code generated by the YAKINDU TypeScript generator, the explanations below are using the _YCar App_ sample state machine, see "figure &quot;The _YCar App_ sample statechart model&quot;":#codegen_ts_fig_the_ycar_app_sample_statechart_model. It models view changes that happen when a user interacts with the menu.

p(#codegen_ts_fig_the_ycar_app_sample_statechart_model).

!(full)images/docu_ts_ycar_menuservice_statechart.png(The _YCar App_ sample statechart model)!

p=. The _YCar App_ sample statechart model



h3(#codegen_ts_generated_code_files). Generated code files

You will find the generated code in the _src/app/gen/_ folder of the ycar app example. If the library target folder is set, you will find some util modules for the generated state machine like _statemachine.interface.ts_ or _eventQueue.ts_ in the specified library target folder.

In the case of the _YCar app_ example, you will find the generated code in the _src/app/gen/statemachine_ folder.

The _statemachine.interface.ts_ module defines the fundamental state machine interface methods. It is needed by each particular state machine and is independend from concrete ones.

The _eventQueue.ts_ module defines the _EventQueue_ class that is needed for the event-driven behavior.



h3(#codegen_ts_the_statemachine_class). The state machine class

The state machine source code is generated as a TypeScript class with the same name as the statechart. For example, if the statechart is named _DefaultSM_ the TypeScript class will also be called _DefaultSM_, and it will be generated in the source code file _defaultSM.statemachine.ts_.

If the state machine is generated as an Angular service, the _defaultSM.statemachine.ts_ module imports Angular dependencies and decorates the class with an _@Injectable_ decorator.

bc..

/**State machine as Angular service **/

import {Injectable} from '@angular/core';
import {EventQueue, Event} from '../stateutils/eventQueue';
import {IStatemachine} from '../stateutils/statemachine.interface';
import {Subject, Subscription} from 'rxjs';

@Injectable()
export class DefaultSM implements IStatemachine  {
	...
}



h3(#codegen_ts_the_statemachine_interface). The statem machine interface

Each generated TypeScript state machine implements the _IStatemachine_ interface  from the _statemachine.interface.ts_ module:

bc..

/**
 * Basic interface for state machines. TEMPLATE BASED
 */
export interface IStatemachine {

	/**
	 * Initializes the state machine. Used to initialize internal variables etc.
	 */
	 init():void;

	/**
	 * Enters the state machine. Sets the state machine into a defined state.
	 */
	enter():void;

	/**
	 * Exits the state machine. Leaves the state machine with a defined state.
	 */
	 exit():void;

	/**
	 * Checks whether the state machine is active.
	 * A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
	 */
	  isActive():boolean;

	/**
	 * Checks whether all active states are final.
	 * If there are no active states then the state machine is considered being incative. In this case this method returns <code>false</code>.
	 */
	  isFinal():boolean;

	/**
	 * Start a run-to-completion cycle.
	 */
	  runCycle():void;
}



h4(#codegen_ts_fundamental_statechart_methods). Fundamental statechart functions

The generated code contains fundamental functions to initialize, enter, and exit a state machine, as well as a function to execute a run-to-completion step.

The _IStatemachine_ interface specifies the four functions _init()_, _enter()_, _exit()_ and _runCycle()_.

###. FIXME (RK): Please check the spelling of the "IStatemachine"!

<ul><li><p>The _init()_ function is used to initialize the internal objects of the state machine right after its instantiation. Variables are initialized to their respective default values. If the statechart defines any initialized variables, these initializations are also done in the _init()_ function.</p></li><li><p>The _enter()_ function must be called to enter the state machine. It brings the state machine to a well-defined state.</p></li><li><p>The _exit()_ function is used to leave a state machine statefully. If for example a history state is used in one of the top regions, the last active state is stored and the state machine is left via _exit()_. Re-entering it via _enter()_ continues to work with the saved state.</p></li><li><p>The _runCycle()_ function is used to trigger a run-to-completion step in which the state machine evaluates arising events and computes possible state changes. Somewhat simplified, a run-to-completion cycle consists of the following steps:</p><ol style="list-style-type:  decimal;"><li><p>Clear the list of outgoing events.</p></li><li><p>Check whether any events have occurred which are leading to a state change.</p></li><li><p>If a state change has to be done:</p><ol style="list-style-type:  decimal;"><li><p>Make the present state inactive.</p></li><li><p>Execute exit actions of the present state.</p></li><li><p>Save history state, if necessary.</p></li><li><p>Execute transition actions, if any.</p></li><li><p>Execute entry actions of the new state.</p></li><li><p>Make the new state active.</p></li></ol></li><li><p>Clear the list of incoming events.</p></li></ol></li></ul>



###. FIXME (RK): Doesn't the TypeScript generator support any timing stuff? I think there should be a section explaining that.



h3(#codegen_ts_accessing_interfaces_variables_and_events). Accessing interfaces, variables and events

The client code can read and write state machine variables and raise state machine events. In a YAKINDU statechart, variables and events are contained in so-called _interfaces_. There can be at most one default, unnamed interface plus zero or more named interfaces. In the generated TypeScript code, these interfaces can be found as classes of the main state machine module.

Let's have a look at the following sample statechart interface declaration of a statechart named _DefaultSM_:

bc. interface Sample:
    var a:boolean
    in event evA:boolean
    out event evB:integer

The generated interface code is shown below in the class _SCISample_, which is part of the _defaultSM.statemachine.ts_ module. Since the statechart's name is _DefaultSM_ the state machine class' name is also _DefaultSM_. It can also be found in the _defaultSM.statemachine.ts_ module file:

###. FIXME (RK): The generated code below uses the term "method" instead of "function" in some comments. This should be fixed in the generator.

bc..

import {EventQueue, Event} from '../stateutils/eventQueue';
import {IStatemachine} from '../stateutils/statemachine.interface';
import {Subject, Subscription} from 'rxjs';

export class DefaultSM implements IStatemachine  {

	// state machine members
	protected initialized:boolean = false;
	protected stateVector:State[] = new Array<State>(1);
	protected  nextStateIndex:number;

	// interface scope
	public readonly Sample:SCISample = new SCISample();

	//EventQueue
	private eventQueue:EventQueue = new EventQueue();

	public init():void {
		for (let i = 0; i < 1; i++) {
			this.stateVector[i] = State.NullState;
		}

		this.clearEvents();
		this.clearOutEvents();

		this.eventQueue.onProcess.subscribe((id)=> {
			this.runCycle();
		});

		this.Sample.a=false;
		this.initialized = true;
		}

	enter():void {
		 if (!this.initialized) {
			throw 'statemachine is not initialized!';
		 }
		this.enterSequence_main_region_default();
	}

	exit():void {
		this.exitSequence_main_region();
	}

	runCycle():void {
		this.clearOutEvents();

		for (this.nextStateIndex = 0; this.nextStateIndex < this.stateVector.length; this.nextStateIndex++) {
			switch (this.stateVector[this.nextStateIndex]) {
			case State.main_region_StateA:
				this.react_main_region_StateA();
				break;
			default:
				// NullState
				break;
			}
		}
		this.clearEvents();
	}

	/**
	 * @see IStatemachine#isActive()
	 */
	public isActive():boolean {
	 	return this.stateVector[0] !== State.NullState;
	}

	/**
	* Always returns 'false' since this state machine can never become final.
	*
  * @see IStatemachine#isFinal()
	 */
	public isFinal():boolean {
		return false;
	}

	/**
	* This function resets the incoming events (time events included).
	*/
	protected  clearEvents():void {
		this.Sample.clearEvents();
	}

	/**
	* This function resets the outgoing events.
	*/
	protected clearOutEvents():void {
		this.Sample.clearOutEvents();
	}

	/**
	* Returns true if the given state is currently active otherwise false.
	*/
	public  isStateActive(state:State):boolean {
		switch (state) {
			case State.main_region_StateA:
				return this.stateVector[0] === State.main_region_StateA;
			default: return false;
		}
	}

	/* 'default' enter sequence for state StateA */
	private  enterSequence_main_region_StateA_default():void {
		this.nextStateIndex = 0;
		this.stateVector[0] = State.main_region_StateA;
	}
	/* 'default' enter sequence for region main region */
	private  enterSequence_main_region_default():void {
		this.react_main_region__entry_Default();
	}
	/* Default exit sequence for state StateA */
	private  exitSequence_main_region_StateA():void {
		this.nextStateIndex = 0;
		this.stateVector[0] = State.NullState;
	}
	/* Default exit sequence for region main region */
	private  exitSequence_main_region():void {
		switch(this.stateVector[0]) {
			case State.main_region_StateA :
				this.exitSequence_main_region_StateA();
				break;

			default:
				break;
		}
	}
	/* The reactions of state StateA. */
	private  react_main_region_StateA():void {
	}
	/* Default react sequence for initial entry  */
	private  react_main_region__entry_Default():void {
		this.enterSequence_main_region_StateA_default();
	}
}

export class SCISample {
	public evA$: Subject<any> = new Subject<any>();

	evAValue:boolean;

	public raiseEvA(value:any):void {
		this.evA$.next(value);
	}

	public subscribeEvA(ev:any): Subscription {
		return ev.subscribe((value) => {
			this.raiseEvA(value);
		})
	}

	private getEvAValue():boolean  {
		return this.evAValue;
	}

	public evB$: Subject<any> = new Subject<any>();

	evBValue:number;

	raiseEvB(value:number):void {
		this.evB$.next(value);
	}

	getEvBValue():number {
		if (this.evBValue === undefined)
			throw "Illegal event value access. Event evB is not raised";
		return this.evBValue;
	}

	public _a:boolean;

	get a():boolean {
		return this._a;
	}
	set a(value:boolean) {
		this._a = value;
	}

	clearEvents():void {}

	clearOutEvents():void {}
 }

export interface IOperationCallback {}

export enum State {
	main_region_StateA,
	NullState
}


p. A statechart interface is generated as a TypeScript class within the state machine module, here _defaultSM.statemachine.ts_. The TypeScript class' name is derived from the statechart interface's name by prepending the string @SCI@.

A special case is the unnamed statechart interface: It is generated as the TypeScript class _SCInterface_.

An incoming event _evA:boolean_ is generated as the raise function _raiseEvA(boolean value)_. Since the event is of type _boolean_ the function has a _boolean_ parameter. In addition to these functions, a subscription function _subscribeEvA(ev:boolean): Subscription_ is generated. It represents a disposable resource, such as the execution of an _Observable_.

For an outgoing event _evB:integer_ the function _getEvBValue(): number_ is generated. The former can be used to determine whether the event has been raised by the state machine or not. The latter serves to query the value of the event. In addition to this, an _Observable_ property _evB$_ of type _Subject_ is generated to subscribe and react on value changes.

For variables, the code generator creates class properties with getter and setter functions, here _get a():boolean_ and _void set a(sc_boolean value)_.

The code generator also creates an appropriately-named _readonly_ instance in the state machine that can be used to acquire this interface, here: _public readonly Sample: SCISample = new SCISample()_.


h3(#codegen_ts_operation_callbacks). Operation callbacks

YAKINDU Statechart Tools support operations that are executed by a state machine as actions, but are implemented by client-side code. The figure below shows a sample statechart using an operation:

!images/docu_operationExample.png(Specifying an operation callback in the model)!

p=. Specifying an operation callback in the model

Let's have a look at the generated code for operation support in the _defaultSM.statemachine.ts_ module:

bc..
export interface IOperationCallback {
	myOperation?(p1: number, p2: boolean);
}

p. An additional interface _IOperationCallback_ with the optional function _myOperation(p1: number, p2: boolean)_ has been generated. The client code has to

* provide an implementation of this interface and
* pass an instance of it to the state machine via the _setSampleOperationCallback(operationCallback: IOperationCallback)_ function.

Here's some sample code that passes an implementation of the operation to a state machine, and then executes the latter:


bc..
import {IOperationCallback, DefaultSM} from "./defaultSM.statemachine";

export class Main {

    defaultSM: DefaultSM ;

    constructor() {
        this.defaultSM = new DefaultSM();
    }

    sampleOperationCallback: IOperationCallback = {
        myOperation: (p1: number, p2: boolean) => {
            console.log("myOperation")
        }
    };

    init(): void {
        this.defaultSM.setSampleOperationCallback(this.sampleOperationCallback);
        this.defaultSM.init();
        this.defaultSM.enter();
        this.defaultSM.runCycle();
    }
}

###. h3(#codegen_ts_integrating_generated_code). Integrating generated code
### TODO
